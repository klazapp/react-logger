{"version":3,"sources":["../src/logger.ts","../src/withDebugProxy.ts","../src/decorators.ts"],"names":["r"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { LogLevel, Logger, EnableFn } from \"./types\";\n\n// Minimal process type declaration for environments without @types/node\ndeclare const process: { env: { NODE_ENV?: string } };\n\n/**\n * Default enablement rule.\n * - In Node: enabled when NODE_ENV !== 'production'.\n * - In browser: enabled if localStorage.debug is truthy and not 'false',\n *   otherwise enabled when NODE_ENV !== 'production'.\n */\nconst defaultEnabled: EnableFn = () => {\n  // Node runtime branch\n  if (typeof window === \"undefined\") {\n    return process.env.NODE_ENV !== \"production\";\n  }\n  // Browser runtime branch\n  const ls = window.localStorage?.getItem(\"debug\");\n  return (ls && ls !== \"false\") || process.env.NODE_ENV !== \"production\";\n};\n\n// Active enablement rule used by the logger\nlet _isEnabled: EnableFn = defaultEnabled;\n\n/**\n * Overrides the active enablement rule.\n * Use to centralize environment-specific toggling (e.g., feature flags).\n */\nexport function setEnableRule(fn: EnableFn) {\n  _isEnabled = fn;\n}\n\n/**\n * Creates a namespaced, leveled logger.\n * - Namespace appears as a bracketed prefix in console output.\n * - 'debug' messages are suppressed when the enablement rule returns false.\n * - Other levels ('info' | 'warn' | 'error') bypass suppression to remain visible.\n */\nexport function makeLogger(ns: string): Logger {\n  const emit =\n      (lvl: LogLevel) =>\n          (...a: any[]) => {\n            if (!_isEnabled() && lvl === \"debug\") return;\n            // Console method selection: 'debug' → console.log; others map 1:1.\n            // eslint-disable-next-line no-console\n            (console as any)[lvl === \"debug\" ? \"log\" : lvl](`[${ns}]`, ...a);\n          };\n  return {\n    debug: emit(\"debug\"),\n    info: emit(\"info\"),\n    warn: emit(\"warn\"),\n    error: emit(\"error\"),\n  };\n}\n\n/**\n * Development-only logger factory.\n * - Expects a build-time global constant __DEV__ defined by the bundler.\n * - When __DEV__ is false, returns no-op functions so calls are tree-shaken or minimized.\n * - When __DEV__ is true, delegates to makeLogger.\n */\ndeclare const __DEV__: boolean | undefined;\n\nexport const makeDevLogger = (ns: string): Logger => {\n  if (typeof __DEV__ !== \"undefined\" && !__DEV__) {\n    const noop = () => {};\n    return { debug: noop, info: noop, warn: noop, error: noop };\n  }\n  return makeLogger(ns);\n};\n","import { makeLogger } from \"./logger\";\nimport type { ProxyOpts } from \"./types\";\n\n/**\n * Creates a Proxy that auto-logs method calls on an object.\n * Behavior:\n *   - Logs method entry with arguments (▶ args)\n *   - Logs successful return values (✅ result)\n *   - Logs thrown errors (❌ error)\n * Coverage:\n *   - Supports synchronous and asynchronous (Promise-like) methods\n * Controls:\n *   - Per-method opt-out via opts.optOut\n *   - Argument/result redaction via opts.redactArgs / opts.redactResult\n *   - Per-method namespace override via opts.namespaceFor\n */\nexport function withDebugProxy<T extends object>(\n    obj: T,\n    name: string,\n    opts: ProxyOpts = {}\n): T {\n    // Base logger for generic errors that are not method-specific\n    const baseLog = makeLogger(name);\n\n    return new Proxy(obj, {\n        get(target, prop, receiver) {\n            const orig = Reflect.get(target, prop, receiver);\n\n            // Preserve non-function properties\n            if (typeof orig !== \"function\") return orig;\n\n            const methodName = String(prop);\n\n            // Skip instrumentation for opted-out methods\n            if (opts.optOut?.(methodName)) return orig;\n\n            // Namespace: \"<name>.<method>\" unless overridden\n            const ns = opts.namespaceFor?.(methodName) ?? `${name}.${methodName}`;\n            const log = makeLogger(ns);\n\n            // Wrapped callable that performs logging around the original method\n            return function (...args: any[]) {\n                // Optional argument redaction/transform before logging\n                const a = opts.redactArgs ? opts.redactArgs(args, methodName) : args;\n                log.debug(\"▶ args:\", a);\n\n                try {\n                    const out = orig.apply(target, args);\n\n                    // Async branch: handle Promise-like results\n                    if (out && typeof (out as any).then === \"function\") {\n                        return (out as Promise<any>)\n                            .then((res) => {\n                                // Optional result redaction/transform before logging\n                                const r = opts.redactResult ? opts.redactResult(res, methodName) : res;\n                                log.debug(\"✅ result:\", r);\n                                return res;\n                            })\n                            .catch((err) => {\n                                baseLog.error(`❌ error in ${methodName}:`, err);\n                                throw err;\n                            });\n                    }\n\n                    // Sync branch: log immediate result\n                    const r = opts.redactResult ? opts.redactResult(out, methodName) : out;\n                    log.debug(\"✅ result:\", r);\n                    return out;\n                } catch (err) {\n                    // Synchronous throw path\n                    baseLog.error(`❌ error in ${methodName}:`, err);\n                    throw err;\n                }\n            };\n        },\n    });\n}\n","import { makeLogger } from \"./logger\";\n\n/**\n * TypeScript method decorator that injects logging for a single method.\n * Behavior:\n *   - Logs method arguments (▶ args)\n *   - Logs return values (✅ result)\n *   - Logs errors (❌ error)\n * Coverage:\n *   - Supports synchronous and asynchronous (Promise-like) methods\n * Parameters:\n *   - ns (optional): custom namespace for log entries; defaults to method name\n */\nexport function DebugLog(ns?: string) {\n    return function (_: any, key: string, d: PropertyDescriptor) {\n        const orig = d.value;\n\n        d.value = function (...args: any[]) {\n            const log = makeLogger(ns ?? key);\n\n            // Log input arguments\n            log.debug(\"▶ args:\", args);\n\n            try {\n                const out = orig.apply(this, args);\n\n                // Async branch: handle Promise results\n                if (out && typeof out.then === \"function\") {\n                    return out\n                        .then((res: any) => {\n                            log.debug(\"✅ result:\", res);\n                            return res;\n                        })\n                        .catch((err: any) => {\n                            log.error(\"❌ error:\", err);\n                            throw err;\n                        });\n                }\n\n                // Sync branch: log return value\n                log.debug(\"✅ result:\", out);\n                return out;\n            } catch (e) {\n                // Log synchronous error\n                log.error(\"❌ error:\", e);\n                throw e;\n            }\n        };\n    };\n}\n"]}